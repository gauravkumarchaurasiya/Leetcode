[
  {
    "leetcode_id": "4-Sum",
    "title": "4 Sum",
    "tags": [
      "array",
      "two pointer"
    ],
    "python_solution": "from typing import List\r\n\r\nclass Solution:\r\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\r\n        nums.sort()\r\n        res = []\r\n        n = len(nums)\r\n\r\n        for i in range(n - 3):\r\n            if i > 0 and nums[i] == nums[i - 1]:\r\n                continue \r\n\r\n            for j in range(i + 1, n - 2):\r\n                if j > i + 1 and nums[j] == nums[j - 1]:\r\n                    continue  \r\n\r\n                left, right = j + 1, n - 1\r\n\r\n                while left < right:\r\n                    total = nums[i] + nums[j] + nums[left] + nums[right]\r\n\r\n                    if total == target:\r\n                        res.append([nums[i], nums[j], nums[left], nums[right]])\r\n                        left += 1\r\n                        right -= 1\r\n\r\n                        while left < right and nums[left] == nums[left - 1]:\r\n                            left += 1\r\n                        while left < right and nums[right] == nums[right + 1]:\r\n                            right -= 1\r\n\r\n                    elif total < target:\r\n                        left += 1\r\n                    else:\r\n                        right -= 1\r\n\r\n        return res"
  },
  {
    "leetcode_id": "subarray-product-less-than-k",
    "title": "Subarray product less than k",
    "tags": [
      "array",
      "two pointer",
      "sliding window"
    ],
    "python_solution": "class Solution:\r\n    def numSubarrayProductLessThanK(self, nums: List[int], k: int) -> int:\r\n        if k <= 1:\r\n            return 0\r\n\r\n        left = 0\r\n        prod = 1\r\n        count = 0\r\n\r\n        for right in range(len(nums)):\r\n            prod *= nums[right]\r\n            while prod >= k and left <= right:\r\n                prod //= nums[left]\r\n                left += 1\r\n            count += right - left + 1\r\n\r\n        return count"
  },
  {
    "leetcode_id": "3sum-smaller",
    "title": "3sum smaller",
    "tags": [
      "array",
      "two pointer"
    ],
    "python_solution": "def threeSumSmaller(nums, target):\r\n    nums.sort()\r\n    count = 0\r\n    n = len(nums)\r\n    \r\n    for i in range(n - 2):\r\n        left, right = i + 1, n - 1\r\n        \r\n        while left < right:\r\n            current_sum = nums[i] + nums[left] + nums[right]\r\n            if current_sum < target:\r\n                # All elements between left and right form valid triplets\r\n                count += right - left\r\n                left += 1\r\n            else:\r\n                right -= 1\r\n                \r\n    return count\r\n"
  },
  {
    "leetcode_id": "3sum-closest",
    "title": "3sum-closest",
    "tags": [
      "array",
      "two pointer"
    ],
    "python_solution": "from typing import List\r\n\r\nclass Solution:\r\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\r\n        nums.sort()\r\n        closest_sum = nums[0] + nums[1] + nums[2]  \r\n\r\n        for i in range(len(nums) - 2):\r\n            left, right = i + 1, len(nums) - 1\r\n\r\n            while left < right:\r\n                curr_sum = nums[i] + nums[left] + nums[right]\r\n                if curr_sum == target:\r\n                    return curr_sum\r\n\r\n\r\n                if abs(curr_sum - target) < abs(closest_sum - target):\r\n                    closest_sum = curr_sum\r\n\r\n                if curr_sum < target:\r\n                    left += 1\r\n                else:\r\n                    right -= 1\r\n\r\n        return closest_sum"
  },
  {
    "leetcode_id": "3sum",
    "title": "3sum",
    "tags": [
      "array",
      "two pointer"
    ],
    "python_solution": "class Solution:\r\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\r\n        nums.sort()\r\n        ans = []\r\n\r\n        for i in range(len(nums)-2):\r\n            if(i>0 and nums[i]==nums[i-1]):\r\n                continue\r\n\r\n            left = i+1\r\n            right = len(nums)-1\r\n            target = -nums[i]\r\n            while(left<right):\r\n                if(nums[left]+nums[right]==target):\r\n                    ans.append([nums[i],nums[left],nums[right]])\r\n                    \r\n                    # Skip duplicates for left pointer\r\n                    while left < right and nums[left] == nums[left + 1]:\r\n                        left += 1\r\n                    # Skip duplicates for right pointer\r\n                    while left < right and nums[right] == nums[right - 1]:\r\n                        right -= 1\r\n\r\n                    left += 1\r\n                    right -= 1\r\n\r\n                elif(nums[left]+nums[right] < target):\r\n                    left+=1\r\n                else:\r\n                    right -=1\r\n                \r\n        return ans"
  },
  {
    "leetcode_id": "squares-of-a-sorted-array",
    "title": "Squares of a sorted array",
    "tags": [
      "array",
      "two pointer"
    ],
    "python_solution": "class Solution:\r\n    def sortedSquares(self, nums: List[int]) -> List[int]:\r\n        left = 0\r\n        right = len(nums)-1\r\n        ans = [0]*len(nums)\r\n        i = right\r\n        while(left<=right):\r\n            if(abs(nums[left])>abs(nums[right])):\r\n                ans[i]= nums[left]**2\r\n                left+=1\r\n            else:\r\n                ans[i]=nums[right]**2\r\n                right-=1\r\n            i-=1\r\n        return ans"
  },
  {
    "leetcode_id": "remove-duplicates-from-sorted-array-ii",
    "title": "Remove duplicates from sorted array ii",
    "tags": [
      "array",
      "two-pointer"
    ],
    "python_solution": "from typing import List\r\n\r\nclass Solution:\r\n    def removeDuplicates(self, arr: List[int]) -> int:\r\n        if len(arr) <= 2:\r\n            return len(arr)\r\n\r\n        prev = 1  \r\n        count = 1\r\n\r\n        for cur in range(1, len(arr)):\r\n            if arr[cur] == arr[cur - 1]:\r\n                count += 1\r\n            else:\r\n                count = 1 \r\n\r\n            if count <= 2:\r\n                arr[prev] = arr[cur]\r\n                prev += 1\r\n\r\n        return prev\r\n"
  },
  {
    "leetcode_id": "find-the-duplicate-number",
    "title": "Find the Duplicate Number",
    "tags": [
      "array",
      "two-pointer"
    ],
    "python_solution": "class Solution:\r\n    def findDuplicate(self, nums: List[int]) -> int:\r\n        slow = nums[0]\r\n        fast = nums[0]\r\n        while True:\r\n            slow = nums[slow]\r\n            fast = nums[nums[fast]]\r\n            if slow == fast:\r\n                break\r\n        fast = nums[0]\r\n        while slow != fast:\r\n            slow = nums[slow]\r\n            fast = nums[fast]\r\n        return slow"
  },
  {
    "leetcode_id": "duplicate-zeros",
    "title": "Duplicate Zeros- Two pointer",
    "tags": [
      "array",
      "two pointer"
    ],
    "python_solution": "class Solution:\r\n    def duplicateZeros(self, arr: List[int]) -> None:\r\n        n = len(arr)\r\n        zeros = 0\r\n        \r\n        # Count how many zeros to duplicate within bounds\r\n        for i in range(n):\r\n            if i + zeros >= n - 1:\r\n                # Handle edge zero\r\n                if i + zeros == n - 1 and arr[i] == 0:\r\n                    arr[n - 1] = 0\r\n                    n -= 1  # Do not duplicate this zero\r\n                break\r\n            if arr[i] == 0:\r\n                zeros += 1\r\n        \r\n        # Second pass: go backwards and shift elements\r\n        for i in range(n - 1 - zeros, -1, -1):\r\n            if arr[i] == 0:\r\n                arr[i + zeros] = 0\r\n                zeros -= 1\r\n                arr[i + zeros] = 0\r\n            else:\r\n                arr[i + zeros] = arr[i]\r\n"
  },
  {
    "leetcode_id": "Remove Duplicates from Sorted List II",
    "title": "Remove Duplicates from Sorted List II",
    "tags": [
      "linkedlist",
      "two-pointer"
    ],
    "python_solution": "# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\r\n        dummy = ListNode(0)\r\n        dummy.next = head\r\n\r\n        prev = dummy\r\n        current = head\r\n\r\n        while(current):\r\n            if(current.next and current.val == current.next.val):\r\n                duplicate = current.val\r\n                while(current and current.val == duplicate):\r\n                    current =current.next\r\n\r\n                prev.next = current\r\n            else:\r\n                prev = current\r\n                current=current.next\r\n                \r\n        return dummy.next"
  },
  {
    "leetcode_id": "Remove Duplicates from Sorted List",
    "title": "Remove Duplicates from Sorted List",
    "tags": [
      "linkedlist",
      "two-pointer"
    ],
    "python_solution": "# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\r\n        if not head:\r\n            return None\r\n        \r\n        temp = head\r\n        while( temp and temp.next):\r\n            if(temp.val == temp.next.val):\r\n                temp.next = temp.next.next\r\n\r\n            else:\r\n                temp = temp.next\r\n        return head"
  },
  {
    "leetcode_id": "two-sum",
    "title": "Two sum using two pointer",
    "tags": [
      "array",
      "two pointer"
    ],
    "python_solution": "class Solution:\r\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\r\n        nums_with_index = list(enumerate(nums))\r\n        \r\n        nums_with_index.sort(key=lambda x: x[1])\r\n        \r\n        # Two-pointer search\r\n        left = 0\r\n        right = len(nums_with_index) - 1\r\n\r\n        while left < right:\r\n            current_sum = nums_with_index[left][1] + nums_with_index[right][1]\r\n            \r\n            if current_sum == target:\r\n                return [nums_with_index[left][0], nums_with_index[right][0]]  \r\n            elif current_sum < target:\r\n                left += 1\r\n            else:\r\n                right -= 1\r\n\r\n        return []\r\n"
  }
]